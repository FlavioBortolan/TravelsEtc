
from django.utils.translation import gettext as _
from django.shortcuts import render
from .forms import UserForm,UserProfileInfoForm
from .forms import DivErrorList
# Extra Imports for the Login and Logout Capabilities
from django.contrib.auth import authenticate, login, logout
#from django.contrib.auth.models import User

from django.http import HttpResponseRedirect, HttpResponse
from django.urls import reverse
from django.contrib.auth.decorators import login_required
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import (TemplateView,ListView,
                                  DetailView,CreateView,
                                  UpdateView,DeleteView)
from django.shortcuts import redirect
from .models import Activity
from .models import Event
from .models import Setting
from .models import Order
from .models import Ticket
from .models import OutMail

from .mailer import Mailer


import string
import random

from django.contrib.auth import get_user_model
from datetime import *
import time
from dateutil.relativedelta import *
from dateutil.rrule import *
from datetime import datetime

import json
import ast

from django.http import JsonResponse
import os
import logging

#see https://stripe.com/docs/payments/integration-builder
import stripe
from django.views.decorators.csrf import csrf_exempt

# This is a sample test API key. Sign in to see examples pre-filled with your key.
#see https://stripe.com/docs/payments/integration-builder
#if key is compromised, regenerate it from the dashboard
stripe.api_key = "sk_test_51JKVSWC9NPB01a0ntYHt93lawC5fmkYHcghlD3ZOwnbScemvFjxC6rfbbHWOsXkuyvdMBfe5C4tpEeRklxMkrBQZ00SfVNyeyW"

#used to simulate payments for debug
stripe_simulate_for_debug = True
User = get_user_model()

import logging
logger = logging.getLogger('logger')

# Create your views here.
def index(request):

    site_under_maintenance = Setting.get_setting('site_under_maintenance')
    logger.info('Site under maintenance:' + str(site_under_maintenance))

    if site_under_maintenance=='True' and not request.user.is_superuser:
        return render(request,'TravelsApp/site_under_maintenance.html')

    return render(request,'TravelsApp/index.html')


@login_required
def special(request):
    # Remember to also set login url in settings.py!
    # LOGIN_URL = '/TravelsApp/user_login/'
    return HttpResponse("You are logged in. Nice!")

@login_required
def user_logout(request):
    # Log out the user.
    logout(request)
    # Return to homepage.
    return HttpResponseRedirect(reverse('index'))


def create_profile(request, user_form, profile_form, autogenerate_password, is_minor):

    logger.info('*** create_profile ***: '+ str(user_form)  + str(profile_form))

    #generate cleaned_data
    user_form.is_valid()

    user_form_ok = False
    #check if fields are valid, skip password fields if password is to be autogenerated
    if 'first_name' in user_form.cleaned_data and \
       'last_name' in user_form.cleaned_data and \
       'email' in user_form.cleaned_data and((   \
       'password' in user_form.cleaned_data and  \
       'repeat_password' in user_form.cleaned_data) or autogenerate_password):
       user_form_ok = True

    else:
        return False, -1, None, None

    logger.info('+++ user_form cleaned_data:' + str(user_form.cleaned_data))

    #logger.info('mail field value =' + user_form.fields['email'].widget.attrs['value'] )
    logger.info('cleaned mail field value =' + user_form.cleaned_data['email'] )

    # Check to see if both forms are valid
    if user_form_ok and profile_form.is_valid():

        logger.info('create_profile:data is ok')
        #get the email supplied trough the form
        supplied_email = user_form.cleaned_data['email']
        logger.info("Supplied mail is:" + supplied_email)

        #check if someone else in the database used that email
        duplicate_users = User.objects.filter(email__iexact = supplied_email).count()

        if duplicate_users == 0:

            logger.info("No duplicate users found")

            if autogenerate_password:
                password = ''.join(random.SystemRandom().choice(string.ascii_uppercase + string.digits) for _ in range(5))
                logger.info('password:' + password)
            else:
                password = user.password

            user = User.objects.create_user(username=supplied_email,
                                 email=supplied_email,
                                 first_name = user_form.cleaned_data['first_name'],
                                 last_name = user_form.cleaned_data['last_name'],
                                 password=None)
            user.save()

            logger.info('new user saved with mail: ' + supplied_email)

            # Hash the password
            user.set_password(password)

            # Update with Hashed password
            user.save()

            logger.info('password saved')

            # Now we deal with the extra info!

            # Can't commit yet because we still need to manipulate
            profile = profile_form.save(commit=False)

            # Set One to One relationship between
            # UserForm and UserProfileInfoForm
            profile.user = user
            profile.is_minor = is_minor

            if is_minor:
                profile.parent = request.user

            '''
            # Check if they provided a profile picture
            if 'profile_pic' in request.FILES:
                logger.info('found it')
                # If yes, then grab it from the POST form reply
                profile.profile_pic = request.FILES['profile_pic']
            '''
            subscription_duration_months = int(Setting.get_setting('subscription_duration_months'))

            #subscription expires after one year, when payment is implemented this will shitf after payment....
            profile.exp_date = datetime.today() + relativedelta(months=+subscription_duration_months)

            # Now save model
            profile.save()
            logger.info('Saving profile info for:')
            logger.info(user.first_name)
            logger.info(user.last_name)
            logger.info(user.email)

            return True, user.id, password, user

        else:
            logger.info(user.email + ' is already registered')
            return False, -1, None, None
    else:
        return False, -1, None, None

def register(request):

    registered = False

    #this flag tells the html page that it is rendered because a POST was issued.
    #and will use this info to preserve the login info in case registration was not correct
    post_response = False

    if request.method == 'POST':

        post_response=True

        # Get info from "both" forms
        # It appears as one form to the user on the .html page
        user_form = UserForm(data=request.POST, error_class=DivErrorList)
        profile_form = UserProfileInfoForm(data=request.POST, error_class=DivErrorList)

        #profile_form.is_valid()
        #logger.info('POST:' + profile_form.cleaned_data['subscription_exp_date'])
        # Check to see both forms are valid
        if user_form.is_valid() and profile_form.is_valid():

            #get the email supplied trough the form
            supplied_email = user_form.cleaned_data['email']
            logger.info("Supplied mail is:" + supplied_email)
            #check if someone else in the database used that email
            duplicate_users = User.objects.filter(email__iexact = supplied_email).count()

            if duplicate_users == 0:

                logger.info("No duplicate users found")

                # Save User Form to Database
                user = user_form.save(commit=False)

                #assign username to be equal to email
                user.username = supplied_email

                user.save()

                # Hash the password
                user.set_password(user.password)

                # Update with Hashed password
                user.save()

                # Now we deal with the extra info!

                # Can't commit yet because we still need to manipulate
                profile = profile_form.save(commit=False)

                # Set One to One relationship between
                # UserForm and UserProfileInfoForm
                profile.user = user

                # Check if they provided a profile picture
                if 'profile_pic' in request.FILES:
                    logger.info('found it')
                    # If yes, then grab it from the POST form reply
                    profile.profile_pic = request.FILES['profile_pic']

                subscription_duration_months = int(Setting.get_setting('subscription_duration_months'))

                #subscription expires after one year, when payment is implemented this will shitf after payment....
                profile.exp_date = datetime.today() + relativedelta(months=+subscription_duration_months)

                # Now save model
                profile.save()

                # Registration Successful!
                registered = True

                user = authenticate(username=supplied_email,
                                    password=user_form.cleaned_data['password'],
                                    )
                login(request, user)

            else:
                # One of the forms was invalid if this else gets called.
                logger.info("Duplicate users where found: There are " + str(duplicate_users) + " users with email " + supplied_email)
        else:
            # One of the forms was invalid if this else gets called.
            logger.info(user_form.errors,profile_form.errors)

    #GET
    else:

        logger.info('register:GET')
        # Just render the forms as blank.
        user_form = UserForm()
        profile_form = UserProfileInfoForm()

    # This is the render and context dictionary to feed
    # back to the registration.html file page.
    return render(request,'TravelsApp/registration.html',
                          {'user_form':user_form,
                           'profile_form':profile_form,
                           'registered':registered,
                           'post_response': post_response })

def my_account(request):

    data_change_successful = False
    credits = request.user.userprofileinfo.credits

    if request.method == 'POST':

        # Get info from "both" forms
        # It appears as one form to the user on the .html page
        user_form = UserForm(data=request.POST, error_class=DivErrorList)
        profile_form = UserProfileInfoForm(data=request.POST, error_class=DivErrorList)

        #disable editing email
        user_form.fields['email'].widget.attrs['disabled'] = True

        #Hide password
        user_form.fields['password'].widget = user_form.fields['email'].hidden_widget()
        user_form.fields['repeat_password'].widget = user_form.fields['repeat_password'].hidden_widget()

        #check if data is valid
        user_form.is_valid()
        profile_form.is_valid()

        # check if fields we care about are clean. a field is clean if it has been put in the 'cleaned_data' dict
        if 'first_name' in user_form.cleaned_data and 'last_name' in user_form.cleaned_data and 'phone_number' in profile_form.cleaned_data :

            request.user.first_name = user_form.cleaned_data['first_name']
            request.user.last_name = user_form.cleaned_data['last_name']

            request.user.userprofileinfo.phone_number = profile_form.cleaned_data['phone_number']
            request.user.userprofileinfo.profile_pic = profile_form.cleaned_data['profile_pic']

            request.user.save()
            request.user.userprofileinfo.save()
            data_change_successful = True

        else:
            # One of the forms was invalid if this else gets called.
            logger.info(user_form.errors,profile_form.errors)

    #GET
    else:
        # Just render the forms as blank.
        user_form = UserForm(initial = {'first_name': request.user.first_name,
                                        'last_name': request.user.last_name,
                                        'email': request.user.email,
                                        })
        profile_form = UserProfileInfoForm(initial = {'phone_number': request.user.userprofileinfo.phone_number, 'exp_date': request.user.userprofileinfo.exp_date})

        #disable editing email
        user_form.fields['email'].widget.attrs['disabled'] = True

        #Hide password
        user_form.fields['password'].widget = user_form.fields['email'].hidden_widget()
        user_form.fields['repeat_password'].widget = user_form.fields['repeat_password'].hidden_widget()


    #Discard errors on the password as we do not edit it here
    user_form.errors['password'] = None
    user_form.errors['repeat_password'] = None

    return render(request,'TravelsApp/my_account.html',
                          {'user_form':user_form,
                           'profile_form':profile_form,
                           'data_change_successful':data_change_successful,
                           'credits': credits,})

def change_password(request):

    data_change_successful = False

    #handle POST, in case of GET we just return the forms created above
    if request.method == 'POST':

        user_form = UserForm(data=request.POST, error_class=DivErrorList)

        #Hide
        user_form.fields['first_name'].widget = user_form.fields['first_name'].hidden_widget()
        user_form.fields['last_name'].widget = user_form.fields['last_name'].hidden_widget()
        user_form.fields['email'].widget = user_form.fields['email'].hidden_widget()

        #check if data is valid
        user_form.is_valid()

        # check if fields we care about are clean. a field is clean if it has been put in the 'cleaned_data' dict
        if 'password' in user_form.cleaned_data and 'repeat_password' in user_form.cleaned_data :

            request.user.set_password(user_form.cleaned_data['password'])
            request.user.save()
            data_change_successful = True

        else:
            # One of the forms was invalid if this else gets called.
            logger.info(user_form.errors)
    else:
        user_form = UserForm()

        #Hide
        user_form.fields['first_name'].widget = user_form.fields['first_name'].hidden_widget()
        user_form.fields['last_name'].widget = user_form.fields['last_name'].hidden_widget()
        user_form.fields['email'].widget = user_form.fields['email'].hidden_widget()


    #Discard errors on the password as we do not edit it here
    user_form.errors['first_name'] = None
    user_form.errors['last_name'] = None
    user_form.errors['email'] = None

    return render(request,'TravelsApp/change_password.html',
                          {'user_form':user_form,
                           'data_change_successful': data_change_successful})

def user_login(request):

    #change this to login with a username=mail

    if request.method == 'POST':
        # First get the username and password supplied
        email = request.POST.get('email')
        password = request.POST.get('password')

        # Django's built-in authentication function:
        user = authenticate(username=email, password=password)

        # If we have a user
        if user:
            #Check it the account is active
            if user.is_active:
                # Log the user in.
                login(request,user)
                # Send the user back to some page.
                # In this case their homepage.
                return HttpResponseRedirect(reverse('index'))
            else:
                # If account is not active:
                return HttpResponse("Your account is not active.")
        else:
            logger.info("Someone tried to login and failed.")
            logger.info("They used email: {} and password: {}".format(email,password))

            return render(request, 'TravelsApp/login.html', {'post_response': 'failed login', 'err_message': 'Invalid email or password, please try again'})
    else:
        #Nothing has been provided for username or password.
        return render(request, 'TravelsApp/login.html', {})

#class EventListView(LoginRequiredMixin, ListView):
class EventListView(ListView):

    #login_url = '/login/'
    redirect_field_name = 'events'
    template_name = 'TravelsApp/event_list.html'
    model = Event

    '''
    #defines the set of elments to be shown (GET)
    #note: *args    = positional arguments in the url call
    #      **kwargs = name-based arguments in the url call
    def get_queryset(self, *args, **kwargs):
        logger.info('***get_queryset: kwargs' + str(**kwargs) + '***')
        if self.kwargs['filter_mode']=='current_user':
            logger.info('filter_mode:' + self.kwargs['filter_mode'] + ', verranno mostrate solo le attivita dell utente attuale')
            return(self.request.user.event_set.all())

        elif self.kwargs['filter_mode']=='all':
            logger.info('filter_mode:' + self.kwargs['filter_mode'] + ', verranno mostrate tutte le attivita')
            return(Event.objects.all())
    '''
    #defines the context dictionary to be used to render page during GET
    def get_context_data(self, **kwargs):

        logger.info('***get_context_data: kwargs' + str(kwargs) + '***')
        context  = super().get_context_data(**kwargs)
        context['filter_mode'] = self.kwargs['filter_mode']

        delta_months = 2
        start_date = time.strftime("%Y-%M-%d", time.strptime(str(date.today()), '%Y-%M-%d'))
        context['start_date'] = start_date

        end_date = time.strftime("%Y-%M-%d", time.strptime(str(date.today() + relativedelta(months=+delta_months)), '%Y-%M-%d'))
        context['end_date'] = end_date

        context['delta_months'] = delta_months


        if self.kwargs['filter_mode']=='current_user':
            logger.info('filter_mode:' + self.kwargs['filter_mode'] + ', verranno mostrate solo le attivita dell utente attuale')

            user_events = self.request.user.event_set.all()
            context['event_list']       = user_events.filter(date__gte = date.today())

        elif self.kwargs['filter_mode']=='current_user_past':
            logger.info('filter_mode:' + self.kwargs['filter_mode'] + ', verranno mostrate solo le attivita passate dell utente attuale')

            user_events = self.request.user.event_set.all()
            context['event_list']  = user_events.filter(date__lt = date.today())

        elif self.kwargs['filter_mode']=='all':
            logger.info('filter_mode:' + self.kwargs['filter_mode'] + ', verranno mostrate tutte le attivita')

            #exclude past events
            context['event_list'] = Event.objects.filter(date__gte = start_date, date__lte = end_date )

        context['event_list'] = context['event_list'].order_by('date')


        logger.info('GET:start_date: ' + start_date)
        logger.info('GET:end_date: ' + end_date)

        return context

    #Handles the 'POST' request from the client browser
    def post(self, request, *args, **kwargs):
        logger.info('POST: filter_mode:' + self.kwargs['filter_mode'] + ', verranno mostrate le attivita corrispondenti ai filtri')

        #get the filter criteria from the POST request(city, start_date etc)
        #these values comes from the form field inside the web page
        city = request.POST.get("city")
        start_date = request.POST.get("start_date")
        end_date = request.POST.get("end_date")
        type = request.POST.get("type")
        difficultyLevel = request.POST.get("difficultyLevel")
        confirmed = request.POST.get("confirmed")

        #Log filter values for debug purposes
        logger.info('POST data:')
        logger.info('City:' + city)
        logger.info('StartDate:' + str(start_date))
        logger.info('EndDate:' + str(end_date))
        query = {}

        #incremental filter by active fields
        filtered_events = Event.objects.all()

        #exclude past events
        filtered_events = filtered_events.filter(date__gte = date.today())

        if city:
            filtered_events = filtered_events.filter(activity__place__iexact = city)

        if type!='NoSelection' and type !='':
            logger.info('filtering events with type =*' + type + '*')
            filtered_events = filtered_events.filter(activity__type = type)

        if confirmed!='NoSelection' and confirmed !='':
            logger.info('filtering events with confirmed =*' + str(confirmed) + '*')
            if confirmed == 'confirmed':
                filtered_events = filtered_events.filter(confirmed = True)

        if difficultyLevel!='NoSelection' and difficultyLevel !='':
            logger.info('filtering events with difficultyLevel =*' + difficultyLevel + '*')
            filtered_events = filtered_events.filter(activity__difficultyLevel = difficultyLevel)

        if start_date:
            logger.info('filtering events with start date >' + start_date )
            filtered_events = filtered_events.filter(date__gte = start_date)

        if end_date:
            logger.info('filtering events with end date >' + end_date)
            filtered_events = filtered_events.filter(date__lte = end_date)

        filtered_events = filtered_events.order_by('date')

        #renders the page with the context dictionary elements set to the values
        #previously calculated
        return render(request,
                      self.template_name,
                      {'event_list': filtered_events,
                       'filter_mode':'apply_filter',
                       'city': city,
                       'start_date': time.strftime("%Y-%M-%d", time.strptime(start_date, '%Y-%M-%d')),
                       'end_date': end_date,
                       'type': type,
                       'difficultyLevel': difficultyLevel,
                       'confirmed': confirmed

                       })

#EVENT MANAGEMENT
class SingleEvent(DetailView):
    model = Event

    def get_queryset(self,*args, **kwargs):
        #logger.info('get_queryset:Selected single activity')
        return(Event.objects.filter(id=self.kwargs['pk']))

    def get_context_data(self,**kwargs):
        context  = super().get_context_data(**kwargs)

        if self.request.user.is_authenticated:

            if self.request.user.event_set.filter(id=self.kwargs['pk']).count()>0:
                context['user_already_has_this_ticket'] = True
                logger.info('The user already has this ticket')
            else:
                context['user_already_has_this_ticket'] = False
                logger.info('The user does not have this ticket')

            if self.request.user.my_queued_events.filter(id=self.kwargs['pk']).count()>0:
                context['queued_to_this_event'] = True
                logger.info('The user is queued to the event')
            else:
                context['queued_to_this_event']  = False
                logger.info('The user is not queued to the event')


        event = Event.objects.filter(id=self.kwargs['pk'])[0]

        #inject the name of the image of the event
        context['event_image_name'] = 'Images/' + event.activity.name + '.jpg'

        #inject the tour start time calculated from meet time + 30 mins
        dt = datetime.combine(event.date, event.time) + timedelta(minutes=30)
        context['start_time'] = dt.time

        if self.request.user.is_authenticated:
            #detect if it is possible to ask for refund
            refund_limit_time = dt - timedelta(hours = event.refund_limit_delta_hours)
            if  refund_limit_time > datetime.now() and context['user_already_has_this_ticket']:
                context['can_ask_refund'] = True
                logger.info('The guy can have his money back as:' + str(refund_limit_time) + '>' + str(datetime.now()))
            else:
                context['can_ask_refund'] = False
                logger.info('The guy cannot have his money back as:' + str(refund_limit_time) + '<' + str(datetime.now()))

        return context


class BuyTicketView(TemplateView):

    template_name = "TravelsApp/buyticket.html"

    def flush(self, om):

        try:
            #setup mailer component
            m = Mailer(sender_email=Setting.get_setting('company_email'), smtp_server = Setting.get_setting('company_email_smtp_server'), password = Setting.get_setting('company_email_password'))

            #send mail
            m.flush_outmail(om)

        except Exception as e:
            logger.error('Could not send mail: ' + str(e))
            return False,

    def get(self, request, *args, **kwargs):

        logger.info('BuyTicket GET was called')
        context  = super().get_context_data(**kwargs)
        #context['Event_pk'] =  kwargs['pk']
        context['pk'] =  kwargs['pk']
        context['buy_step'] =  kwargs['buy_step']
        context['friend_id'] = kwargs['friend_id']

        if kwargs['buy_step']=='partecipant_selection':
            logger.info('BuyTicket.get:' + kwargs['buy_step'] + ' ' + kwargs['cmd'] )

            if kwargs['cmd']=='init':
                logger.info('cmd=' + kwargs['cmd'] )

        elif kwargs['buy_step']=='collect_friends_mail':
            logger.info('BuyTicket.get:' + kwargs['buy_step'] + ' ' + kwargs['cmd'] )

            if kwargs['cmd']=='init':

                logger.info('received registration data')
                user_form = UserForm( error_class = DivErrorList)
                profile_form = UserProfileInfoForm( error_class = DivErrorList)
                user_form.fields['email'].widget.attrs['value'] = friend_mail
                user_form.fields['email'].widget.attrs['disabled'] = True
                user_form.fields['password'].widget = user_form.fields['email'].hidden_widget()
                user_form.fields['repeat_password'].widget = user_form.fields['repeat_password'].hidden_widget()

                context['user_form'] = user_form
                context['profile_form'] = profile_form


        elif kwargs['buy_step']=='friend_already_subscibed':
            logger.info('BuyTicket.get:' + kwargs['buy_step'] + ' ' + kwargs['cmd'] )

        elif kwargs['buy_step']=='collect_friends_data':
            logger.info('BuyTicket.get:' + kwargs['buy_step'] + ' ' + kwargs['cmd'] )

            if kwargs['cmd']=='init':

                #friend = User.objects.get(id=int(kwargs['friend_id']))

                logger.info('received registration data')
                user_form = UserForm( error_class = DivErrorList)
                profile_form = UserProfileInfoForm( error_class = DivErrorList)
                #user_form.fields['email'].widget.attrs['value'] = friend.mail
                user_form.fields['email'].widget.attrs['disabled'] = True
                user_form.fields['password'].widget = user_form.fields['email'].hidden_widget()
                user_form.fields['repeat_password'].widget = user_form.fields['repeat_password'].hidden_widget()

                context['user_form'] = user_form
                context['profile_form'] = profile_form

        elif kwargs['buy_step']=='registration_successful':
            logger.info('BuyTicket.get:' + kwargs['buy_step'] + ' ' + kwargs['cmd'] )
            logger.info('registration_successful, friend_id = ' + str(kwargs['friend_id']))

        elif kwargs['buy_step']=='confirmation':
            logger.info('BuyTicket.get:' + kwargs['buy_step'] + ' ' + kwargs['cmd'] )

            if kwargs['friend_id'] != '-1':
                partecipant = User.objects.get(id = int(kwargs['friend_id']))
            else:
                partecipant = self.request.user
            #xxx
            #res, context_out, order = open_order(context['pk'], self.request.user, partecipant)
            year_subscription_price = int(Setting.get_setting('year_subscription_price'))
            res, context_out, order = Order.open_order(context['pk'], self.request.user, partecipant, year_subscription_price)
            context = { **context,  **context_out}
            logger.info('BuyTicketView: confirmation, context = ' + str(context))

        elif kwargs['buy_step']=='card_pay_successful':
            logger.info('BuyTicket.get:' + kwargs['buy_step'] + ' ' + kwargs['cmd'] )

        elif kwargs['buy_step']=='confirmed':
            logger.info('BuyTicket.get:' + kwargs['buy_step'] + ' ' + kwargs['cmd'] )

            logger.info('Closing order from -confirmed-')
            o = Order.objects.get(id=kwargs['order_id'])
            subscription_duration_months = int(Setting.get_setting('subscription_duration_months'))
            ret = o.close(subscription_duration_months)

            if ret:
                #send mail with order confirmation
                logger.info('Creating mail for order confirmation')
                om = OutMail.create_from_order(o, request)

                self.flush(om)

        return render(request,
                      self.template_name,
                      context)

    def minor_mail_from_name(self, minor_name, minor_last_name, parent):
        minor_mail =  minor_name + '.' + minor_last_name + '_minor_by_' + parent.email
        return minor_mail

    def post(self, request, *args, **kwargs):

        logger.info('BuyTicket POST was called')
        context  = super().get_context_data(**kwargs)
        #context['Event_pk'] =  kwargs['pk']
        context['pk'] =  kwargs['pk']
        context['buy_step'] =  kwargs['buy_step']
        context['friend_id'] = kwargs['friend_id']

        if kwargs['buy_step']=='conditions_acceptance':

            #Just pass the buy_step=conditions_acceptance to the buyticket.html that will show the conditions
            logger.info('buy_step=conditions_acceptance')
            logger.info('cmd=acceptance_for_me')
            logger.info('pk=' + str(context['pk']))
            logger.info('context:'+ str(context))
            
        elif kwargs['buy_step']=='partecipant_selection':

            context['ticket_target_user'] = request.POST.get('ticket_target_user')

            if kwargs['cmd']=='receive_user_selected':
                logger.info('cmd=' + kwargs['cmd'] )

                #ticket for me: go to the confirmation page
                if context['ticket_target_user'] == 'me':

                    return redirect('TravelsApp:buyticket', pk = context['pk'], buy_step ="confirmation", cmd="init", total = 0, credits_to_use = 0, order_id = 0, friend_id='-1')

                #ticket for friend: collect friend's email
                elif context['ticket_target_user'] == 'friend':

                    print ('****** collecting friends email ******')
                    user_form = UserForm(error_class=DivErrorList)

                    #Hide all fields except email
                    user_form.fields['password'].widget = user_form.fields['password'].hidden_widget()
                    user_form.fields['repeat_password'].widget = user_form.fields['repeat_password'].hidden_widget()
                    user_form.fields['first_name'].widget = user_form.fields['first_name'].hidden_widget()
                    user_form.fields['last_name'].widget = user_form.fields['last_name'].hidden_widget()

                    context['user_form'] = user_form

                    context['buy_step'] = 'collect_friends_mail'

                #ticket for friend: collect friend's email
                elif context['ticket_target_user'] == 'minor':

                    print ('****** collecting minor name ******')
                    user_form = UserForm(error_class=DivErrorList)

                    #Hide all fields except email
                    user_form.fields['password'].widget = user_form.fields['password'].hidden_widget()
                    user_form.fields['repeat_password'].widget = user_form.fields['repeat_password'].hidden_widget()
                    user_form.fields['email'].widget = user_form.fields['email'].hidden_widget()
                    user_form.fields['last_name'].widget = user_form.fields['last_name'].hidden_widget()

                    context['user_form'] = user_form

                    context['buy_step'] = 'collect_friends_mail'

        elif kwargs['buy_step']=='collect_friends_mail':

            if kwargs['cmd'] == 'receive_email':

                friend_mail = request.POST.get('email')
                friend_match = User.objects.filter(email=friend_mail)

                logger.info('buy_step=collect_friends_mail, cmd=receive_email: mail=' + friend_mail)
                logger.info('matches:' + str(friend_match.count()))

                #check if friend mail corresponds to a user
                if friend_match.count()>0:
                    logger.info('The friend is already a member')
                    friend = friend_match[0]

                    #check if friend is already subscribed to the event
                    e = Event.objects.get(id=context['pk'])
                    if e.partecipants.filter(email = friend.email ).count()>0:
                        logger.info('friend is already subscribed')
                        return redirect('TravelsApp:buyticket', pk = context['pk'], buy_step ="friend_already_subscibed", cmd='init', total = 0, credits_to_use = 0, order_id = 0, friend_id = friend.id)

                    #redirect to buy ticket for him
                    else:
                        return redirect('TravelsApp:buyticket', pk = context['pk'], buy_step ="confirmation", cmd='init', total = 0, credits_to_use = 0, order_id = 0, friend_id = friend.id)

                #friend needs registration
                else:
                    logger.info(friend_mail + ' has to register')

                    user_form = UserForm( error_class = DivErrorList)
                    profile_form = UserProfileInfoForm( error_class = DivErrorList)
                    user_form.fields['email'].widget.attrs['value'] = friend_mail
                    user_form.fields['email'].widget.attrs['readonly'] = True
                    user_form.fields['password'].widget = user_form.fields['email'].hidden_widget()
                    user_form.fields['repeat_password'].widget = user_form.fields['repeat_password'].hidden_widget()

                    context['user_form'] = user_form
                    context['profile_form'] = profile_form
                    context['buy_step']='collect_friends_data'
                    context['ticket_target_user']='friend'

            elif kwargs['cmd'] == 'receive_minor_name':

                #build minor name using name plus mail of parent (the parent must be the current user, also for legal reasons)
                minor_name = request.POST.get('first_name')
                minor_last_name = request.POST.get('last_name')

                minor_mail =  self.minor_mail_from_name(minor_name, minor_last_name, request.user)
                friend_match = User.objects.filter(email = minor_mail)

                #check if kid's mail corresponds to a user
                if friend_match.count()>0:
                    logger.info('The friend is already a member')
                    friend = friend_match[0]

                    #check if friend is already subscribed to the event
                    e = Event.objects.get(id=context['pk'])
                    if e.partecipants.filter(email = friend.email ).count()>0:
                        logger.info('friend is already subscribed')
                        return redirect('TravelsApp:buyticket', pk = context['pk'], buy_step ="friend_already_subscibed", cmd='init', total = 0, credits_to_use = 0, order_id = 0, friend_id = friend.id)

                    #redirect to buy ticket for him
                    else:
                        return redirect('TravelsApp:buyticket', pk = context['pk'], buy_step ="confirmation", cmd='init', total = 0, credits_to_use = 0, order_id = 0, friend_id = friend.id)

                #kid needs registration
                else:
                    logger.info(minor_name + ' has to register')

                    user_form = UserForm( error_class = DivErrorList)
                    profile_form = UserProfileInfoForm( error_class = DivErrorList)

                    user_form.fields['first_name'].widget.attrs['value'] = minor_name
                    user_form.fields['first_name'].widget.attrs['readonly'] = True

                    user_form.fields['email'].widget.attrs['value'] = minor_mail
                    user_form.fields['email'].widget = user_form.fields['email'].hidden_widget()

                    user_form.fields['password'].widget = user_form.fields['password'].hidden_widget()
                    user_form.fields['repeat_password'].widget = user_form.fields['repeat_password'].hidden_widget()
                    profile_form.fields['phone_number'].widget = profile_form.fields['phone_number'].hidden_widget()

                    context['user_form'] = user_form
                    context['profile_form'] = profile_form
                    context['buy_step']='collect_friends_data'
                    context['ticket_target_user']='minor'

        elif kwargs['buy_step']=='collect_friends_data':

            if kwargs['cmd'] == 'receive_friends_data':

                friend_mail = request.POST.get('email')
                logger.info('+++received email:' + str(friend_mail))

                tmp_data = request.POST.copy()
                tmp_data['email'] = friend_mail
                user_form = UserForm(data=tmp_data, error_class=DivErrorList)
                profile_form = UserProfileInfoForm(data=request.POST, error_class=DivErrorList)
                #user_form.fields['email'].widget.attrs['disabled'] = True
                user_form.fields['password'].widget = user_form.fields['password'].hidden_widget()
                user_form.fields['repeat_password'].widget = user_form.fields['repeat_password'].hidden_widget()

                (ret, friend_id, pw, new_user) = create_profile(request, user_form, profile_form, True, False)

                if ret:

                    om = OutMail.create_from_site_subscription_completed( request.user, new_user, pw, 'friend', request)
                    self.flush(om)

                    return redirect('TravelsApp:buyticket', pk = context['pk'], buy_step ="registration_successful", cmd='init', total = 0, credits_to_use = 0, order_id = 0, friend_id = friend_id)
                    #manda mail nuovo utente
                    #manda una comunicazione che utente registrato e mail inviata

                else:

                    #Discard errors on the password as we do not edit it here
                    user_form.errors['password'] = None
                    user_form.errors['repeat_password'] = None
                    context['user_form'] = user_form
                    context['profile_form'] = profile_form
                    context['buy_step'] = 'collect_friends_data'
                    context['ticket_target_user'] = 'friend'

                    logger.info('poop')

            if kwargs['cmd'] == 'receive_minor_data':

                minor_mail = \
                self.minor_mail_from_name(request.POST.get('first_name'), request.POST.get('last_name'), request.user)

                logger.info('+++minor autogenerated mail:' + minor_mail)

                tmp_data = request.POST.copy()
                tmp_data['email'] = minor_mail
                user_form = UserForm(data=tmp_data, error_class=DivErrorList)
                profile_form = UserProfileInfoForm(data=request.POST, error_class=DivErrorList)

                #feed kid mail
                user_form.fields['password'].widget = user_form.fields['password'].hidden_widget()
                user_form.fields['repeat_password'].widget = user_form.fields['repeat_password'].hidden_widget()

                (ret, friend_id, pw, new_user) = create_profile(request, user_form, profile_form, True, True)

                if ret:

                    om = OutMail.create_from_site_subscription_completed( request.user, new_user, pw, 'minor', request )
                    self.flush(om)

                    return redirect('TravelsApp:buyticket', pk = context['pk'], buy_step ="registration_successful", cmd='init', total = 0, credits_to_use = 0, order_id = 0, friend_id = friend_id)
                    #manda mail nuovo utente
                    #manda una comunicazione che utente registrato e mail inviata

                else:
                    #Discard errors on the password as we do not edit it here
                    user_form.errors['password'] = None
                    user_form.errors['repeat_password'] = None
                    context['user_form'] = user_form
                    context['profile_form'] = profile_form
                    context['buy_step'] = 'collect_friends_data'
                    context['ticket_target_user'] = 'friend'
                    logger.info('poop')

        return render(request,
                      self.template_name,
                      context)

class AskRefundView(TemplateView):
    template_name = "TravelsApp/ask_refund.html"

    def get_refund_coices(self, ticket):

        logger.info('*** get_refund_coices ***')
        r_context={}

        price = ticket.event.activity.price
        #get ticket id from event, user,
        tot_card = ticket.order.total

        logger.info('Ticket id = ' + str(ticket.id) + ', price = ' + str(price) + ', tot_card = ' + str(tot_card))

        #define which refund options there are
        if tot_card == 0:

            r_context['choices'] = "credits"
            r_context['max_amount_card'] = 0

        elif price <= tot_card:
            #card or credits
            r_context['choices'] = "card_or_credits"
            #if card is chosen, maximim amount for card is the price of the ticket.
            r_context['max_amount_card'] = price

        elif price > tot_card:
            #mixed card and credits refund or credits only
            r_context['choices'] ="card_plus_credit_or_credits"
            #the maximum that can be refunded to card is the total paid with card in the order
            r_context['max_amount_card'] = tot_card

        r_context['price'] = price

        logger.info(str(r_context))
        return r_context

    def get_context_data(self,**kwargs):
        context  = super().get_context_data(**kwargs)
        context['event'] = Event.objects.get(id=kwargs['pk'])
        context['refund_step'] =  kwargs['refund_step']

        ticket = Ticket.objects.filter(user=self.request.user, event = context['event'], status = 'valid' )[0]
        r_context = self.get_refund_coices(ticket)

        context = {**context , **r_context}

        return context

    def refund_ticket_with_card(self, ticket, amount):

        logger.info('*** refund_ticket ***: user = ' + ticket.user.email + ', event = ' + ticket.event.activity.name + ', amount = ' + str(amount) )

        #get order id from ticket id
        order = ticket.order

        #refund for the amount given
        smallest_currency_ratio = int(Setting.get_setting('smallest_currency_ratio'))
        try:
            logger.info('refunding payment_intent:' + order.payment_id)
            #https://stripe.com/docs/payments/integration-builder
            r = stripe.Refund.create(
            payment_intent = order.payment_id,
            amount = amount*smallest_currency_ratio)
            logger.info(str(r))

            return True, None

        except Exception as e:
            logger.error('error refund payment intent:' + str(e))
            return False, e

    #Handles the 'POST' request from the client browser
    def post(self, request, *args, **kwargs):

        refund = request.POST.get("refund")
        logger.info('Post: refund requested: ' + str(refund))

        context  = super().get_context_data(**kwargs)
        context['event'] = Event.objects.get(id=kwargs['pk'])
        context['refund_step'] =  2

        #check if user is subscribed to the event , this is to avoid a user arrives here with the 'back' button after having already unsubscribed
        if request.user in context['event'].partecipants.all():

            context['user_subscribed'] = True

            #get ticket id from event, user,
            ticket = Ticket.objects.filter(user=self.request.user, event = context['event'], status = 'valid' )[0]

            refund_dict = self.get_refund_coices(ticket)

            #how much to refund in credits
            credits_refund = 0
            #how much to refund with card
            card_refund = 0

            if refund == 'credits':

                credits_refund = refund_dict['price']
                card_refund = 0

            elif refund == 'card':

                credits_refund = 0
                card_refund = refund_dict['price']

            elif refund == 'card_plus_credits':

                credits_refund = refund_dict['price'] - refund_dict['max_amount_card']
                card_refund = refund_dict['max_amount_card']

            #successful card payment
            ret_card = True
            if card_refund > 0:

                #bank refund
                card_refund_cost = int(Setting.get_setting('card_refund_cost'))
                net_refund = card_refund - card_refund_cost

                ret_card, e = self.refund_ticket_with_card(ticket, net_refund)

                if ret_card:
                    print ('Refund of ' + str(net_refund) + 'euros done (' + str(card_refund) + '-' + str(card_refund_cost) +')')
                    context['event'].partecipants.remove(request.user)
                    context['event'].save()
                    context['refund_result'] = "success"
                else:
                    print ('Error refunding payment: ' + str(e))
                    context['refund_result'] = str(e)

            #refund credits
            ret_cred = True
            if credits_refund>0 and ret_card:#do not proceed refunding credits if there was issue with card
                request.user.userprofileinfo.credits += credits_refund
                print ('refunding Credits...')
                request.user.userprofileinfo.save()
                ret_cred = True

            if ret_cred and ret_card:
                #remove user from partecipants
                context['event'].partecipants.remove(request.user)
                context['event'].save()
                context['refund_result'] = "success"
                ticket.status='refunded'
                ticket.save()

        else:
            print ('user is not subscibed...')
            context['user_subscribed'] = False

        return render(request,
                      self.template_name,
                      context)

class QueueToEventView(TemplateView):
    template_name = "TravelsApp/queue_to_event.html"

    #Handles the 'POST' request from the client browser
    def get(self, request, *args, **kwargs):

        logger.info('QueueToEventView.POST')
        context  = super().get_context_data(**kwargs)
        context['event'] = Event.objects.get(id=kwargs['pk'])

        #Is the user queued to this event
        if context['event'].queued_partecipants.filter(username=request.user.username).count()>0 :
            context['user_queued'] = True
        else:
            context['user_queued'] = False

        #Gestire il caso in cui l'utente è già in coda ma chiede di essere accodato nel html

        if kwargs['command'] == 'add_me':
            #add current user to the queue
            context['event'].queued_partecipants.add(request.user)
            context['event'].save()
            context['cmd']  ='add_me'
            print ('user added to queue')

        elif kwargs['command'] == 'remove_me':
            #remove current user to the queue
            context['event'].queued_partecipants.remove(request.user)
            context['event'].save()
            context['cmd']  = 'remove_me'
            print ('user removed from queue')

        return render(request,
                      self.template_name,
                      context)

class CardPayView(TemplateView):
    template_name = "TravelsApp/card_pay.html"

    def get_context_data(self,**kwargs):
        context  = super().get_context_data(**kwargs)
        context['total'] = kwargs['amount']
        context['payment_intent_address'] = reverse('TravelsApp:create_payment_intent')
        context['order_id'] = kwargs['order_id']
        context['friend_id'] = kwargs['friend_id']

        return context

    #Handles the 'POST' request from the client browser
    def post(self, request, *args, **kwargs):
        print ('post called, useless')



def create_payment_intent(request):

    eur_cents = 100
    if request.method == "POST":

        total=int(json.loads(request.body)['total'])
        order_id=int(json.loads(request.body)['order_id'])

        logger.info('Creating payment intent for order_id:' + str(order_id) + ' ,total: ' + str(total) )
        logger.info('request:' + str(request.body))

        try:
            #see https://stripe.com/docs/payments/integration-builder
            intent = stripe.PaymentIntent.create(
                amount = total*eur_cents,
                currency='eur' #move to Setting
            )

            logger.info('intent' + str(intent))
            logger.info('************ intent id:' + str(intent['id']) + '************')

            #update the order
            o = Order.objects.get(id=order_id)
            o.payment_id = intent['id']

            #for debug purposes
            if stripe_simulate_for_debug == True:
                o.payment_id = 'this is just a dummy id'

            o.save()

            return JsonResponse({
              'clientSecret': intent['client_secret']
            })

        except Exception as e:
            logger.error('error creting intent:' + str(e))
            return JsonResponse({'error':str(e), })

#see for integration:
# https://stripe.com/docs/payments/integration-builder
#for webhook test:
#https://stripe.com/docs/webhooks/test
#https://stripe.com/docs/stripe-cli/webhooks#forward-events

#forward events to web hook(local):
#stripe listen --forward-to http://127.0.0.1:8000/TravelsApp/stripe_webhook/

#forward events to web hook(server):
#stripe listen --forward-to https://flaviobortolan.pythonanywhere.com/TravelsApp/stripe_webhook/

#trigger an event:
#stripe trigger payment_intent.succeeded

@csrf_exempt
def stripe_webhook(request):

    logger.info('+++++++++stripe_webhook called+++++++++++')

    payload = request.body
    event = None

    try:
        event = stripe.Event.construct_from(
          json.loads(payload), stripe.api_key
        )
    except ValueError as e:
        # Invalid payload
        return HttpResponse(status=400)

    # Handle the event
    event_dict = event.to_dict()
    if event_dict['type'] == "payment_intent.succeeded":
        intent = event_dict['data']['object']

        print ("Succeeded: ", intent['id'])

        #fetch order based on intent id and update database accordingly ->events, credits, queue etc
        try:
            #retrive the order correspondig to the intent id
            #o = Order.objects.filter(status='chart', payment_id = intent['id'])[0]

            #overwrite for debug purposes
            #set stripe_simulate_for_debug to false during real life
            if stripe_simulate_for_debug == True:
                o = Order.objects.filter(status__iexact='chart', payment_id__iexact = 'this is just a dummy id')[0]
            else:
                #retrive the order correspondig to the intent id
                o = Order.objects.filter(status='chart', payment_id = intent['id'])[0]

            logger.info('Payment receved for order id: ' + str(o.id))

        except Exception as ex:
            logger.error('Receved stripe hook call for unexisting intent with id:' + intent['id'])
            logger.error(str(ex))
            return HttpResponse(status=400)

        logger.info('Closing order from -webhook-')
        subscription_duration_months = int(Setting.get_setting('subscription_duration_months'))
        ret = o.close(subscription_duration_months)

        if ret:

            logger.info('Creating mail for order confirmation')
            om = OutMail.create_from_order(o, request)

            try:
                #setup mailer component
                m = Mailer(sender_email=Setting.get_setting('company_email'), smtp_server = Setting.get_setting('company_email_smtp_server'), password = Setting.get_setting('company_email_password'))

                #send mail with order confirmation
                m.flush_outmail(om)

            except Exception as e:
                logger.info('Could not send mail: ' + str(e))
                return False,

            return HttpResponse(status=200)

    elif event_dict['type'] == "payment_intent.payment_failed":
        intent = event_dict['data']['object']
        error_message = intent['last_payment_error']['message'] if intent.get('last_payment_error') else None
        print ("Failed: ", intent['id'], error_message)
        # Notify the customer that payment failed
        return HttpResponse(status=400)
    else:
        return HttpResponse(status=400)
